import{PublicKey as e}from"@solana/web3.js";import{encode as r}from"../node_modules/punycode/punycode.es6.mjs";import{bech32 as t}from"../node_modules/@scure/base/lib/esm/index.mjs";import{i as o}from"../node_modules/ipaddr.js/lib/ipaddr.mjs";import{check as s}from"../utils/check.mjs";import{Record as n}from"../types/record.mjs";import{InvalidEvmAddressError as m,InvalidInjectiveAddressError as f,InvalidARecordError as i,InvalidAAAARecordError as c,InvalidRecordInputError as u}from"../error.mjs";import{UTF8_ENCODED as d,EVM_RECORDS as a}from"./const.mjs";const p=(p,h)=>{if(d.has(h))return h!==n.CNAME&&h!==n.TXT||(p=r(p)),Buffer.from(p,"utf-8");if(h===n.SOL)return new e(p).toBuffer();if(a.has(h))return s("0x"===p.slice(0,2),new m("The record content must start with `0x`")),Buffer.from(p.slice(2),"hex");if(h===n.Injective){const e=t.decodeToBytes(p);return s("inj"===e.prefix,new f("The record content must start with `inj")),s(20===e.bytes.length,new f("The record data must be 20 bytes long")),Buffer.from(e.bytes)}if(h===n.A){const e=o.parse(p).toByteArray();return s(4===e.length,new i("The record content must be 4 bytes long")),Buffer.from(e)}if(h===n.AAAA){const e=o.parse(p).toByteArray();return s(16===e.length,new c("The record content must be 16 bytes long")),Buffer.from(e)}throw new u("The record content is malformed")};export{p as serializeRecordV2Content};
//# sourceMappingURL=serializeRecordV2Content.mjs.map
