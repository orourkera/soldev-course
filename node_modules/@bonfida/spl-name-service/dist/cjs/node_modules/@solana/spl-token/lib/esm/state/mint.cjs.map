{"version":3,"file":"mint.cjs","sources":["../../../../../../../../node_modules/@solana/spl-token/lib/esm/state/mint.js"],"sourcesContent":["import { struct, u32, u8 } from '@solana/buffer-layout';\nimport { bool, publicKey, u64 } from '@solana/buffer-layout-utils';\nimport { PublicKey } from '@solana/web3.js';\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from '../constants.js';\nimport { TokenAccountNotFoundError, TokenInvalidAccountOwnerError, TokenInvalidAccountSizeError, TokenInvalidMintError, TokenOwnerOffCurveError, } from '../errors.js';\nimport { ACCOUNT_TYPE_SIZE, AccountType } from '../extensions/accountType.js';\nimport { getMintLen } from '../extensions/extensionType.js';\nimport { ACCOUNT_SIZE } from './account.js';\nimport { MULTISIG_SIZE } from './multisig.js';\n/** Buffer layout for de/serializing a mint */\nexport const MintLayout = struct([\n    u32('mintAuthorityOption'),\n    publicKey('mintAuthority'),\n    u64('supply'),\n    u8('decimals'),\n    bool('isInitialized'),\n    u32('freezeAuthorityOption'),\n    publicKey('freezeAuthority'),\n]);\n/** Byte length of a mint */\nexport const MINT_SIZE = MintLayout.span;\n/**\n * Retrieve information about a mint\n *\n * @param connection Connection to use\n * @param address    Mint account\n * @param commitment Desired level of commitment for querying the state\n * @param programId  SPL Token program account\n *\n * @return Mint information\n */\nexport async function getMint(connection, address, commitment, programId = TOKEN_PROGRAM_ID) {\n    const info = await connection.getAccountInfo(address, commitment);\n    return unpackMint(address, info, programId);\n}\n/**\n * Unpack a mint\n *\n * @param address   Mint account\n * @param info      Mint account data\n * @param programId SPL Token program account\n *\n * @return Unpacked mint\n */\nexport function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {\n    if (!info)\n        throw new TokenAccountNotFoundError();\n    if (!info.owner.equals(programId))\n        throw new TokenInvalidAccountOwnerError();\n    if (info.data.length < MINT_SIZE)\n        throw new TokenInvalidAccountSizeError();\n    const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));\n    let tlvData = Buffer.alloc(0);\n    if (info.data.length > MINT_SIZE) {\n        if (info.data.length <= ACCOUNT_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data.length === MULTISIG_SIZE)\n            throw new TokenInvalidAccountSizeError();\n        if (info.data[ACCOUNT_SIZE] != AccountType.Mint)\n            throw new TokenInvalidMintError();\n        tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);\n    }\n    return {\n        address,\n        mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,\n        supply: rawMint.supply,\n        decimals: rawMint.decimals,\n        isInitialized: rawMint.isInitialized,\n        freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,\n        tlvData,\n    };\n}\n/** Get the minimum lamport balance for a mint to be rent exempt\n *\n * @param connection Connection to use\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMint(connection, commitment) {\n    return await getMinimumBalanceForRentExemptMintWithExtensions(connection, [], commitment);\n}\n/** Get the minimum lamport balance for a rent-exempt mint with extensions\n *\n * @param connection Connection to use\n * @param extensions Extension types included in the mint\n * @param commitment Desired level of commitment for querying the state\n *\n * @return Amount of lamports required\n */\nexport async function getMinimumBalanceForRentExemptMintWithExtensions(connection, extensions, commitment) {\n    const mintLen = getMintLen(extensions);\n    return await connection.getMinimumBalanceForRentExemption(mintLen, commitment);\n}\n/**\n * Async version of getAssociatedTokenAddressSync\n * For backwards compatibility\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Promise containing the address of the associated token account\n */\nexport async function getAssociatedTokenAddress(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = await PublicKey.findProgramAddress([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n/**\n * Get the address of the associated token account for a given mint and owner\n *\n * @param mint                     Token mint account\n * @param owner                    Owner of the new account\n * @param allowOwnerOffCurve       Allow the owner account to be a PDA (Program Derived Address)\n * @param programId                SPL Token program account\n * @param associatedTokenProgramId SPL Associated Token program account\n *\n * @return Address of the associated token account\n */\nexport function getAssociatedTokenAddressSync(mint, owner, allowOwnerOffCurve = false, programId = TOKEN_PROGRAM_ID, associatedTokenProgramId = ASSOCIATED_TOKEN_PROGRAM_ID) {\n    if (!allowOwnerOffCurve && !PublicKey.isOnCurve(owner.toBuffer()))\n        throw new TokenOwnerOffCurveError();\n    const [address] = PublicKey.findProgramAddressSync([owner.toBuffer(), programId.toBuffer(), mint.toBuffer()], associatedTokenProgramId);\n    return address;\n}\n//# sourceMappingURL=mint.js.map"],"names":["MintLayout","struct","u32","publicKey","u64","u8","bool","MINT_SIZE","span","unpackMint","address","info","programId","TOKEN_PROGRAM_ID","TokenAccountNotFoundError","owner","equals","TokenInvalidAccountOwnerError","data","length","TokenInvalidAccountSizeError","rawMint","decode","slice","tlvData","Buffer","alloc","ACCOUNT_SIZE","MULTISIG_SIZE","AccountType","Mint","TokenInvalidMintError","ACCOUNT_TYPE_SIZE","mintAuthority","mintAuthorityOption","supply","decimals","isInitialized","freezeAuthority","freezeAuthorityOption","mint","allowOwnerOffCurve","associatedTokenProgramId","ASSOCIATED_TOKEN_PROGRAM_ID","PublicKey","isOnCurve","toBuffer","TokenOwnerOffCurveError","findProgramAddressSync","async","connection","commitment","getAccountInfo"],"mappings":"mcAmDaA,EAAaC,EAAAA,OAAgB,CACtCC,EAAAA,IAAI,uBACJC,EAAAA,UAAU,iBACVC,EAAGA,IAAC,UACJC,EAAEA,GAAC,YACHC,OAAK,iBACLJ,EAAAA,IAAI,yBACJC,EAAAA,UAAU,qBAIDI,EAAYP,EAAWQ,KA+B9B,SAAUC,EAAWC,EAAoBC,EAAkCC,EAAYC,EAAAA,kBACzF,IAAKF,EAAM,MAAM,IAAIG,EAAAA,0BACrB,IAAKH,EAAKI,MAAMC,OAAOJ,GAAY,MAAM,IAAIK,EAAAA,8BAC7C,GAAIN,EAAKO,KAAKC,OAASZ,EAAW,MAAM,IAAIa,EAAAA,6BAE5C,MAAMC,EAAUrB,EAAWsB,OAAOX,EAAKO,KAAKK,MAAM,EAAGhB,IACrD,IAAIiB,EAAUC,OAAOC,MAAM,GAC3B,GAAIf,EAAKO,KAAKC,OAASZ,EAAW,CAC9B,GAAII,EAAKO,KAAKC,QAAUQ,EAAAA,aAAc,MAAM,IAAIP,EAAAA,6BAChD,GAAIT,EAAKO,KAAKC,SAAWS,EAAAA,cAAe,MAAM,IAAIR,EAAAA,6BAClD,GAAIT,EAAKO,KAAKS,iBAAiBE,EAAWA,YAACC,KAAM,MAAM,IAAIC,EAAAA,sBAC3DP,EAAUb,EAAKO,KAAKK,MAAMI,EAAYA,aAAGK,EAAiBA,kBAC9D,CAEA,MAAO,CACHtB,UACAuB,cAAeZ,EAAQa,oBAAsBb,EAAQY,cAAgB,KACrEE,OAAQd,EAAQc,OAChBC,SAAUf,EAAQe,SAClBC,cAAehB,EAAQgB,cACvBC,gBAAiBjB,EAAQkB,sBAAwBlB,EAAQiB,gBAAkB,KAC3Ed,UAER,gFAyEM,SACFgB,EACAzB,EACA0B,GAAqB,EACrB7B,EAAYC,EAAAA,iBACZ6B,EAA2BC,+BAE3B,IAAKF,IAAuBG,EAAAA,UAAUC,UAAU9B,EAAM+B,YAAa,MAAM,IAAIC,EAAAA,wBAE7E,MAAOrC,GAAWkC,EAAAA,UAAUI,uBACxB,CAACjC,EAAM+B,WAAYlC,EAAUkC,WAAYN,EAAKM,YAC9CJ,GAGJ,OAAOhC,CACX,kBAlIOuC,eACHC,EACAxC,EACAyC,EACAvC,EAAYC,EAAAA,kBAGZ,OAAOJ,EAAWC,QADCwC,EAAWE,eAAe1C,EAASyC,GACrBvC,EACrC","x_google_ignoreList":[0]}