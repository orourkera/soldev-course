"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var t=require("../../../../_virtual/Layout.cjs"),e=require("../../../../_virtual/index.cjs");require("../../../buffer/index.cjs"),Object.defineProperty(t.__exports,"__esModule",{value:!0}),t.__exports.s16=t.__exports.s8=t.__exports.nu64be=t.__exports.u48be=t.__exports.u40be=t.__exports.u32be=t.__exports.u24be=t.__exports.u16be=t.__exports.nu64=t.__exports.u48=t.__exports.u40=exports.u32=t.__exports.u32=t.__exports.u24=t.__exports.u16=exports.u8=t.__exports.u8=t.__exports.offset=t.__exports.greedy=t.__exports.Constant=t.__exports.UTF8=t.__exports.CString=t.__exports.Blob=t.__exports.Boolean=t.__exports.BitField=t.__exports.BitStructure=t.__exports.VariantLayout=t.__exports.Union=t.__exports.UnionLayoutDiscriminator=t.__exports.UnionDiscriminator=t.__exports.Structure=t.__exports.Sequence=t.__exports.DoubleBE=t.__exports.Double=t.__exports.FloatBE=t.__exports.Float=t.__exports.NearInt64BE=t.__exports.NearInt64=t.__exports.NearUInt64BE=t.__exports.NearUInt64=t.__exports.IntBE=t.__exports.Int=t.__exports.UIntBE=t.__exports.UInt=t.__exports.OffsetLayout=t.__exports.GreedyCount=t.__exports.ExternalLayout=t.__exports.bindConstructorLayout=t.__exports.nameWithProperty=t.__exports.Layout=t.__exports.uint8ArrayToBuffer=t.__exports.checkUint8Array=void 0,t.__exports.constant=t.__exports.utf8=t.__exports.cstr=exports.blob=t.__exports.blob=t.__exports.unionLayoutDiscriminator=t.__exports.union=t.__exports.seq=t.__exports.bits=exports.struct=t.__exports.struct=t.__exports.f64be=t.__exports.f64=t.__exports.f32be=t.__exports.f32=t.__exports.ns64be=t.__exports.s48be=t.__exports.s40be=t.__exports.s32be=t.__exports.s24be=t.__exports.s16be=t.__exports.ns64=t.__exports.s48=t.__exports.s40=t.__exports.s32=t.__exports.s24=void 0;const r=e.__exports;function n(t){if(!(t instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}function o(t){return n(t),r.Buffer.from(t.buffer,t.byteOffset,t.length)}t.__exports.checkUint8Array=n,t.__exports.uint8ArrayToBuffer=o;class s{constructor(t,e){if(!Number.isInteger(t))throw new TypeError("span must be an integer");this.span=t,this.property=e}makeDestinationObject(){return{}}getSpan(t,e){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(t){const e=Object.create(this.constructor.prototype);return Object.assign(e,this),e.property=t,e}fromArray(t){}}function i(t,e){return e.property?t+"["+e.property+"]":t}t.__exports.Layout=s,t.__exports.nameWithProperty=i,t.__exports.bindConstructorLayout=function(t,e){if("function"!=typeof t)throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(t,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof s))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");t.layout_=e,e.boundConstructor_=t,e.makeDestinationObject=()=>new t,Object.defineProperty(t.prototype,"encode",{value(t,r){return e.encode(this,t,r)},writable:!0}),Object.defineProperty(t,"decode",{value:(t,r)=>e.decode(t,r),writable:!0})};class a extends s{isCount(){throw new Error("ExternalLayout is abstract")}}t.__exports.ExternalLayout=a;class u extends a{constructor(t=1,e){if(!Number.isInteger(t)||0>=t)throw new TypeError("elementSpan must be a (positive) integer");super(-1,e),this.elementSpan=t}isCount(){return!0}decode(t,e=0){n(t);const r=t.length-e;return Math.floor(r/this.elementSpan)}encode(t,e,r){return 0}}t.__exports.GreedyCount=u;class p extends a{constructor(t,e=0,r){if(!(t instanceof s))throw new TypeError("layout must be a Layout");if(!Number.isInteger(e))throw new TypeError("offset must be integer or undefined");super(t.span,r||t.property),this.layout=t,this.offset=e}isCount(){return this.layout instanceof c||this.layout instanceof d}decode(t,e=0){return this.layout.decode(t,e+this.offset)}encode(t,e,r=0){return this.layout.encode(t,e,r+this.offset)}}t.__exports.OffsetLayout=p;class c extends s{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return o(t).readUIntLE(e,this.span)}encode(t,e,r=0){return o(e).writeUIntLE(t,r,this.span),this.span}}t.__exports.UInt=c;class d extends s{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return o(t).readUIntBE(e,this.span)}encode(t,e,r=0){return o(e).writeUIntBE(t,r,this.span),this.span}}t.__exports.UIntBE=d;class _ extends s{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return o(t).readIntLE(e,this.span)}encode(t,e,r=0){return o(e).writeIntLE(t,r,this.span),this.span}}t.__exports.Int=_;class h extends s{constructor(t,e){if(super(t,e),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(t,e=0){return o(t).readIntBE(e,this.span)}encode(t,e,r=0){return o(e).writeIntBE(t,r,this.span),this.span}}t.__exports.IntBE=h;const l=Math.pow(2,32);function f(t){const e=Math.floor(t/l);return{hi32:e,lo32:t-e*l}}function y(t,e){return t*l+e}class x extends s{constructor(t){super(8,t)}decode(t,e=0){const r=o(t),n=r.readUInt32LE(e);return y(r.readUInt32LE(e+4),n)}encode(t,e,r=0){const n=f(t),s=o(e);return s.writeUInt32LE(n.lo32,r),s.writeUInt32LE(n.hi32,r+4),8}}t.__exports.NearUInt64=x;class w extends s{constructor(t){super(8,t)}decode(t,e=0){const r=o(t);return y(r.readUInt32BE(e),r.readUInt32BE(e+4))}encode(t,e,r=0){const n=f(t),s=o(e);return s.writeUInt32BE(n.hi32,r),s.writeUInt32BE(n.lo32,r+4),8}}t.__exports.NearUInt64BE=w;class b extends s{constructor(t){super(8,t)}decode(t,e=0){const r=o(t),n=r.readUInt32LE(e);return y(r.readInt32LE(e+4),n)}encode(t,e,r=0){const n=f(t),s=o(e);return s.writeUInt32LE(n.lo32,r),s.writeInt32LE(n.hi32,r+4),8}}t.__exports.NearInt64=b;class g extends s{constructor(t){super(8,t)}decode(t,e=0){const r=o(t);return y(r.readInt32BE(e),r.readUInt32BE(e+4))}encode(t,e,r=0){const n=f(t),s=o(e);return s.writeInt32BE(n.hi32,r),s.writeUInt32BE(n.lo32,r+4),8}}t.__exports.NearInt64BE=g;class m extends s{constructor(t){super(4,t)}decode(t,e=0){return o(t).readFloatLE(e)}encode(t,e,r=0){return o(e).writeFloatLE(t,r),4}}t.__exports.Float=m;class E extends s{constructor(t){super(4,t)}decode(t,e=0){return o(t).readFloatBE(e)}encode(t,e,r=0){return o(e).writeFloatBE(t,r),4}}t.__exports.FloatBE=E;class v extends s{constructor(t){super(8,t)}decode(t,e=0){return o(t).readDoubleLE(e)}encode(t,e,r=0){return o(e).writeDoubleLE(t,r),8}}t.__exports.Double=v;class L extends s{constructor(t){super(8,t)}decode(t,e=0){return o(t).readDoubleBE(e)}encode(t,e,r=0){return o(e).writeDoubleBE(t,r),8}}t.__exports.DoubleBE=L;class S extends s{constructor(t,e,r){if(!(t instanceof s))throw new TypeError("elementLayout must be a Layout");if(!(e instanceof a&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let n=-1;!(e instanceof a)&&0<t.span&&(n=e*t.span),super(n,r),this.elementLayout=t,this.count=e}getSpan(t,e=0){if(0<=this.span)return this.span;let r=0,n=this.count;if(n instanceof a&&(n=n.decode(t,e)),0<this.elementLayout.span)r=n*this.elementLayout.span;else{let o=0;for(;o<n;)r+=this.elementLayout.getSpan(t,e+r),++o}return r}decode(t,e=0){const r=[];let n=0,o=this.count;for(o instanceof a&&(o=o.decode(t,e));n<o;)r.push(this.elementLayout.decode(t,e)),e+=this.elementLayout.getSpan(t,e),n+=1;return r}encode(t,e,r=0){const n=this.elementLayout,o=t.reduce(((t,o)=>t+n.encode(o,e,r+t)),0);return this.count instanceof a&&this.count.encode(t.length,e,r),o}}t.__exports.Sequence=S;class I extends s{constructor(t,e,r){if(!Array.isArray(t)||!t.reduce(((t,e)=>t&&e instanceof s),!0))throw new TypeError("fields must be array of Layout instances");"boolean"==typeof e&&void 0===r&&(r=e,e=void 0);for(const e of t)if(0>e.span&&void 0===e.property)throw new Error("fields cannot contain unnamed variable-length layout");let n=-1;try{n=t.reduce(((t,e)=>t+e.getSpan()),0)}catch(t){}super(n,e),this.fields=t,this.decodePrefixes=!!r}getSpan(t,e=0){if(0<=this.span)return this.span;let r=0;try{r=this.fields.reduce(((r,n)=>{const o=n.getSpan(t,e);return e+=o,r+o}),0)}catch(t){throw new RangeError("indeterminate span")}return r}decode(t,e=0){n(t);const r=this.makeDestinationObject();for(const n of this.fields)if(void 0!==n.property&&(r[n.property]=n.decode(t,e)),e+=n.getSpan(t,e),this.decodePrefixes&&t.length===e)break;return r}encode(t,e,r=0){const n=r;let o=0,s=0;for(const n of this.fields){let i=n.span;if(s=0<i?i:0,void 0!==n.property){const o=t[n.property];void 0!==o&&(s=n.encode(o,e,r),0>i&&(i=n.getSpan(e,r)))}o=r,r+=i}return o+s-n}fromArray(t){const e=this.makeDestinationObject();for(const r of this.fields)void 0!==r.property&&0<t.length&&(e[r.property]=t.shift());return e}layoutFor(t){if("string"!=typeof t)throw new TypeError("property must be string");for(const e of this.fields)if(e.property===t)return e}offsetOf(t){if("string"!=typeof t)throw new TypeError("property must be string");let e=0;for(const r of this.fields){if(r.property===t)return e;0>r.span?e=-1:0<=e&&(e+=r.span)}}}t.__exports.Structure=I;class B{constructor(t){this.property=t}decode(t,e){throw new Error("UnionDiscriminator is abstract")}encode(t,e,r){throw new Error("UnionDiscriminator is abstract")}}t.__exports.UnionDiscriminator=B;class U extends B{constructor(t,e){if(!(t instanceof a&&t.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(e||t.property||"variant"),this.layout=t}decode(t,e){return this.layout.decode(t,e)}encode(t,e,r){return this.layout.encode(t,e,r)}}t.__exports.UnionLayoutDiscriminator=U;class D extends s{constructor(t,e,r){let n;if(t instanceof c||t instanceof d)n=new U(new p(t));else if(t instanceof a&&t.isCount())n=new U(t);else{if(!(t instanceof B))throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");n=t}if(void 0===e&&(e=null),!(null===e||e instanceof s))throw new TypeError("defaultLayout must be null or a Layout");if(null!==e){if(0>e.span)throw new Error("defaultLayout must have constant span");void 0===e.property&&(e=e.replicate("content"))}let o=-1;e&&(o=e.span,0<=o&&(t instanceof c||t instanceof d)&&(o+=n.layout.span)),super(o,r),this.discriminator=n,this.usesPrefixDiscriminator=t instanceof c||t instanceof d,this.defaultLayout=e,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(t){return i(t)},this.configGetSourceVariant=function(t){i=t.bind(this)}}getSpan(t,e=0){if(0<=this.span)return this.span;const r=this.getVariant(t,e);if(!r)throw new Error("unable to determine span for unrecognized variant");return r.getSpan(t,e)}defaultGetSourceVariant(t){if(Object.prototype.hasOwnProperty.call(t,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(t,this.defaultLayout.property))return;const e=this.registry[t[this.discriminator.property]];if(e&&(!e.layout||e.property&&Object.prototype.hasOwnProperty.call(t,e.property)))return e}else for(const e in this.registry){const r=this.registry[e];if(r.property&&Object.prototype.hasOwnProperty.call(t,r.property))return r}throw new Error("unable to infer src variant")}decode(t,e=0){let r;const n=this.discriminator,o=n.decode(t,e),s=this.registry[o];if(void 0===s){const s=this.defaultLayout;let i=0;this.usesPrefixDiscriminator&&(i=n.layout.span),r=this.makeDestinationObject(),r[n.property]=o,r[s.property]=s.decode(t,e+i)}else r=s.decode(t,e);return r}encode(t,e,r=0){const n=this.getSourceVariant(t);if(void 0===n){const n=this.discriminator,o=this.defaultLayout;let s=0;return this.usesPrefixDiscriminator&&(s=n.layout.span),n.encode(t[n.property],e,r),s+o.encode(t[o.property],e,r+s)}return n.encode(t,e,r)}addVariant(t,e,r){const n=new T(this,t,e,r);return this.registry[t]=n,n}getVariant(t,e=0){let r;return r=t instanceof Uint8Array?this.discriminator.decode(t,e):t,this.registry[r]}}t.__exports.Union=D;class T extends s{constructor(t,e,r,n){if(!(t instanceof D))throw new TypeError("union must be a Union");if(!Number.isInteger(e)||0>e)throw new TypeError("variant must be a (non-negative) integer");if("string"==typeof r&&void 0===n&&(n=r,r=null),r){if(!(r instanceof s))throw new TypeError("layout must be a Layout");if(null!==t.defaultLayout&&0<=r.span&&r.span>t.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if("string"!=typeof n)throw new TypeError("variant must have a String property")}let o=t.span;0>t.span&&(o=r?r.span:0,0<=o&&t.usesPrefixDiscriminator&&(o+=t.discriminator.layout.span)),super(o,n),this.union=t,this.variant=e,this.layout=r||null}getSpan(t,e=0){if(0<=this.span)return this.span;let r=0;this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span);let n=0;return this.layout&&(n=this.layout.getSpan(t,e+r)),r+n}decode(t,e=0){const r=this.makeDestinationObject();if(this!==this.union.getVariant(t,e))throw new Error("variant mismatch");let n=0;return this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout?r[this.property]=this.layout.decode(t,e+n):this.property?r[this.property]=!0:this.union.usesPrefixDiscriminator&&(r[this.union.discriminator.property]=this.variant),r}encode(t,e,r=0){let n=0;if(this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(t,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,e,r);let o=n;if(this.layout&&(this.layout.encode(t[this.property],e,r+n),o+=this.layout.getSpan(e,r+n),0<=this.union.span&&o>this.union.span))throw new Error("encoded variant overruns containing union");return o}fromArray(t){if(this.layout)return this.layout.fromArray(t)}}function O(t){return 0>t&&(t+=4294967296),t}t.__exports.VariantLayout=T;class k extends s{constructor(t,e,r){if(!(t instanceof c||t instanceof d))throw new TypeError("word must be a UInt or UIntBE layout");if("string"==typeof e&&void 0===r&&(r=e,e=!1),4<t.span)throw new RangeError("word cannot exceed 32 bits");super(t.span,r),this.word=t,this.msb=!!e,this.fields=[];let n=0;this._packedSetValue=function(t){return n=O(t),this},this._packedGetValue=function(){return n}}decode(t,e=0){const r=this.makeDestinationObject(),n=this.word.decode(t,e);this._packedSetValue(n);for(const e of this.fields)void 0!==e.property&&(r[e.property]=e.decode(t));return r}encode(t,e,r=0){const n=this.word.decode(e,r);this._packedSetValue(n);for(const e of this.fields)if(void 0!==e.property){const r=t[e.property];void 0!==r&&e.encode(r)}return this.word.encode(this._packedGetValue(),e,r)}addField(t,e){const r=new j(this,t,e);return this.fields.push(r),r}addBoolean(t){const e=new P(this,t);return this.fields.push(e),e}fieldFor(t){if("string"!=typeof t)throw new TypeError("property must be string");for(const e of this.fields)if(e.property===t)return e}}t.__exports.BitStructure=k;class j{constructor(t,e,r){if(!(t instanceof k))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(e)||0>=e)throw new TypeError("bits must be positive integer");const n=8*t.span,o=t.fields.reduce(((t,e)=>t+e.bits),0);if(e+o>n)throw new Error("bits too long for span remainder ("+(n-o)+" of "+n+" remain)");this.container=t,this.bits=e,this.valueMask=(1<<e)-1,32===e&&(this.valueMask=4294967295),this.start=o,this.container.msb&&(this.start=n-o-e),this.wordMask=O(this.valueMask<<this.start),this.property=r}decode(t,e){return O(this.container._packedGetValue()&this.wordMask)>>>this.start}encode(t){if("number"!=typeof t||!Number.isInteger(t)||t!==O(t&this.valueMask))throw new TypeError(i("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const e=this.container._packedGetValue(),r=O(t<<this.start);this.container._packedSetValue(O(e&~this.wordMask)|r)}}t.__exports.BitField=j;class P extends j{constructor(t,e){super(t,1,e)}decode(t,e){return!!super.decode(t,e)}encode(t){"boolean"==typeof t&&(t=+t),super.encode(t)}}t.__exports.Boolean=P;class C extends s{constructor(t,e){if(!(t instanceof a&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let r=-1;t instanceof a||(r=t),super(r,e),this.length=t}getSpan(t,e){let r=this.span;return 0>r&&(r=this.length.decode(t,e)),r}decode(t,e=0){let r=this.span;return 0>r&&(r=this.length.decode(t,e)),o(t).slice(e,e+r)}encode(t,e,r){let n=this.length;if(this.length instanceof a&&(n=t.length),!(t instanceof Uint8Array&&n===t.length))throw new TypeError(i("Blob.encode",this)+" requires (length "+n+") Uint8Array as src");if(r+n>e.length)throw new RangeError("encoding overruns Uint8Array");const s=o(t);return o(e).write(s.toString("hex"),r,n,"hex"),this.length instanceof a&&this.length.encode(n,e,r),n}}t.__exports.Blob=C;class V extends s{constructor(t){super(-1,t)}getSpan(t,e=0){n(t);let r=e;for(;r<t.length&&0!==t[r];)r+=1;return 1+r-e}decode(t,e=0){const r=this.getSpan(t,e);return o(t).slice(e,e+r-1).toString("utf-8")}encode(t,e,n=0){"string"!=typeof t&&(t=String(t));const s=r.Buffer.from(t,"utf8"),i=s.length;if(n+i>e.length)throw new RangeError("encoding overruns Buffer");const a=o(e);return s.copy(a,n),a[n+i]=0,i+1}}t.__exports.CString=V;class N extends s{constructor(t,e){if("string"==typeof t&&void 0===e&&(e=t,t=void 0),void 0===t)t=-1;else if(!Number.isInteger(t))throw new TypeError("maxSpan must be an integer");super(-1,e),this.maxSpan=t}getSpan(t,e=0){return n(t),t.length-e}decode(t,e=0){const r=this.getSpan(t,e);if(0<=this.maxSpan&&this.maxSpan<r)throw new RangeError("text length exceeds maxSpan");return o(t).slice(e,e+r).toString("utf-8")}encode(t,e,n=0){"string"!=typeof t&&(t=String(t));const s=r.Buffer.from(t,"utf8"),i=s.length;if(0<=this.maxSpan&&this.maxSpan<i)throw new RangeError("text length exceeds maxSpan");if(n+i>e.length)throw new RangeError("encoding overruns Buffer");return s.copy(o(e),n),i}}t.__exports.UTF8=N;class A extends s{constructor(t,e){super(0,e),this.value=t}decode(t,e){return this.value}encode(t,e,r){return 0}}t.__exports.Constant=A,t.__exports.greedy=(t,e)=>new u(t,e),t.__exports.offset=(t,e,r)=>new p(t,e,r),exports.u8=t.__exports.u8=t=>new c(1,t),t.__exports.u16=t=>new c(2,t),t.__exports.u24=t=>new c(3,t),exports.u32=t.__exports.u32=t=>new c(4,t),t.__exports.u40=t=>new c(5,t),t.__exports.u48=t=>new c(6,t),t.__exports.nu64=t=>new x(t),t.__exports.u16be=t=>new d(2,t),t.__exports.u24be=t=>new d(3,t),t.__exports.u32be=t=>new d(4,t),t.__exports.u40be=t=>new d(5,t),t.__exports.u48be=t=>new d(6,t),t.__exports.nu64be=t=>new w(t),t.__exports.s8=t=>new _(1,t),t.__exports.s16=t=>new _(2,t),t.__exports.s24=t=>new _(3,t),t.__exports.s32=t=>new _(4,t),t.__exports.s40=t=>new _(5,t),t.__exports.s48=t=>new _(6,t),t.__exports.ns64=t=>new b(t),t.__exports.s16be=t=>new h(2,t),t.__exports.s24be=t=>new h(3,t),t.__exports.s32be=t=>new h(4,t),t.__exports.s40be=t=>new h(5,t),t.__exports.s48be=t=>new h(6,t),t.__exports.ns64be=t=>new g(t),t.__exports.f32=t=>new m(t),t.__exports.f32be=t=>new E(t),t.__exports.f64=t=>new v(t),t.__exports.f64be=t=>new L(t),exports.struct=t.__exports.struct=(t,e,r)=>new I(t,e,r),t.__exports.bits=(t,e,r)=>new k(t,e,r),t.__exports.seq=(t,e,r)=>new S(t,e,r),t.__exports.union=(t,e,r)=>new D(t,e,r),t.__exports.unionLayoutDiscriminator=(t,e)=>new U(t,e),exports.blob=t.__exports.blob=(t,e)=>new C(t,e),t.__exports.cstr=t=>new V(t),t.__exports.utf8=(t,e)=>new N(t,e),t.__exports.constant=(t,e)=>new A(t,e),exports.default=t.__exports;
//# sourceMappingURL=Layout.cjs.map
